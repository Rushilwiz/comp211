// Do not edit this file

#include <math.h>
#include "task.h"

#ifndef _SCHEDULE_H_
#define _SCHEDULE_H_

// For preemptive scheduling algorithms, the maximum time slice that a task can
// be run for before a context switch to another task
#define QUANTUM 5

/**
 * Run task on the CPU for its total number of remaining cycles.
 *
 * Print "Task {pid} ran for {remaining_cycles} cycle(s)."
 * Set task's remaining_cycles to 0.
 * Print "Task {pid} completed."
 *
 * @param task
 * @return void
 */
void run_to_completion(task_struct* task);

/**
 * Run task on the CPU for a maximum time quantum.
 *
 * If remaining_cycles <= quantum, then call run_to_completion.
 *
 * Else, decrement task's remaining_cycles by quantum
 * and print "Task {pid} ran for {quantum} cycle(s)."
 *
 * @param task
 * @param quantum
 * @return void
 */
void run_with_quantum(task_struct* task, unsigned int quantum);

/**
 * Implement the first come first serve (FCFS) scheduling algorithm.
 *
 * While the queue is not empty:
 *  - Get the task at the front of the queue.
 *  - Remove and run the task to completion.
 *
 * @return void
 */
void fcfs();

/**
 * Implement the priority queue scheduling algorithm.
 *
 * While the queue is not empty:
 *  - Min heapify the linked list.
 *  - Get the highest priority task from the list (the one at the head).
 *  - Remove and run the highest priority task for the given quantum.
 *  - If the task is not complete, then append it to the linked list.
 *
 * @param quantum
 * @return void
 */
void priority_queue(unsigned int quantum);

/**
 * Implement the round robin scheduling algorithm.
 *
 * While the linked list is not empty:
 *  - Get the task in the list at ( index + 1 ) % list size.
 *  - Run the task for the given quantum.
 *  - If the task is complete, then remove it from the list.
 *
 * @param quantum
 * @return void
 */
void round_robin(unsigned int quantum);

#endif
